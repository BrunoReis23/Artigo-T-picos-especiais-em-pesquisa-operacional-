# -*- coding: utf-8 -*-
"""ARIMAprevisão.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14WUEOcD2LjJ8yKRWPLIMq2DHKUIwwxdV
"""

#carregar os pacotes
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import itertools
import statsmodels.api as sm
from datetime import datetime

from statsmodels.graphics.tsaplots import month_plot, quarter_plot
from statsmodels.tsa.seasonal import seasonal_decompose
from pandas.plotting import autocorrelation_plot
from statsmodels.tsa.stattools import acf, pacf
from statsmodels.graphics.tsaplots import plot_acf,plot_pacf
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.statespace.tools import diff
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.gofplots import qqplot
from statsmodels.stats.stattools import jarque_bera
import scipy.stats as sct
from scipy import stats
from statsmodels.tools.eval_measures import rmse
from sklearn.metrics import mean_absolute_error
from sklearn.metrics import mean_squared_error
from matplotlib import pyplot

#ler os dados
import csv
dados = pd.read_csv('/content/observados - Página1.csv')

dados

from matplotlib import pyplot as plt
dados['observados'].plot(kind='line', figsize=(8, 4), title='Série Temporal')
plt.gca().spines[['top', 'right']].set_visible(False)

#eliminar os warnings das bibliotecas. Configura o Python para ignorar todas as mensagens de aviso que são emitidas durante a execução do código
import warnings
warnings.filterwarnings("ignore")

#funções FAC e FACP

lag_acf = acf(dados, nlags=20)
lag_pacf = pacf(dados, nlags=15)
dados.plot(figsize=(15, 6))
#plt.figure(figsize=(12, 6))
plt.subplot(121)
plt.stem(lag_acf)
plt.title('Função de Autocorrelação')

plt.subplot(122)
plt.stem(lag_pacf)
plt.title('Função de Autocorrelação Parcial')
plt.show()

#Teste Fuller
Teste=adfuller(dados)
adf_statistic = Teste[0]
p_value = Teste[1]

print("Estatística ADF:", adf_statistic)
print("Valor-p:", p_value)

if p_value <= 0.05:
    print("A série é estacionária (p <= 0.05).")
else:
    print("A série não é estacionária (p > 0.05).")

# Teste da média zero para verificar estacionariedade
t_statistic, p_value = stats.ttest_1samp(dados, 0)

if p_value < 0.05:  # Usando um nível de significância de 0,05
    print('A média não é estatisticamente igual a zero. A série não é estacionária.')
else:
    print('A média é estatisticamente igual a zero. A série pode ser estacionária.')

vendas_diff = dados.diff().dropna()

vendas_diff

from matplotlib import pyplot as plt
vendas_diff['observados'].plot(kind='line', figsize=(8, 4), title='Diferenciação')
plt.gca().spines[['top', 'right']].set_visible(False)

#Teste Dickey Fuller
Teste2=adfuller(vendas_diff)
adf_statistic = Teste2[0]
p_value = Teste2[1]

print("Estatística ADF:", adf_statistic)
print("Valor-p:", p_value)

if p_value <= 0.05:
    print("A série é estacionária (p <= 0.05).")
else:
    print("A série não é estacionária (p > 0.05).")

#funções FAC e FACP

lag_acf = acf(vendas_diff, nlags=15)
lag_pacf = pacf(vendas_diff, nlags=8)
dados.plot(figsize=(15, 6))
plt.subplot(121)
plt.stem(lag_acf)
plt.title('Função de Autocorrelação')

plt.subplot(122)
plt.stem(lag_pacf)
plt.title('Função de Autocorrelação Parcial')
plt.show()

#Rodar o ARIMA automático
!pip install pmdarima

from pmdarima.arima import auto_arima

model = auto_arima(dados, seasonal=False, stepwise=True, suppress_warnings=True, error_action="ignore")
results3 = model.fit(dados)
print(results3)

#Previsões
forecast_steps = 5  # Especifique o número de passos à frente que deseja prever
forecast3 = results3.predict(n_periods=forecast_steps)
conf_int3 = results3.predict(n_periods=forecast_steps, return_conf_int=True)

plt.figure(figsize=(12, 8))
plt.plot(dados, label='Dados de Vendas Observados')
plt.plot(range(len(dados), len(dados) + forecast_steps), forecast3, color='red', label='Previsão de Vendas')

#Cálculo do MAPE
#Neste código, a função float() é usada para converter o resultado do MAPE em um número de ponto flutuante antes de usar a string de formatação :.2f para exibir apenas duas casas decimais. Isso deve resolver o erro e permitir que você imprima o MAPE corretamente.
actual_values = dados[-5:]  # Valores reais
forecast_1 = forecast3[-5:]
mape = float(mean_absolute_error(actual_values, forecast_1) / np.mean(actual_values) * 100)
print(f"MAPE: {mape:.2f}%")
print(actual_values)

mod = ARIMA(dados['observados'], order=(1,1,3))
res = mod.fit()
fig = res.predict(start=79, end=88)
fig

plt.figure(figsize=(12, 8))
plt.plot(dados, label='Dados de Vendas Observados')
plt.plot(fig)